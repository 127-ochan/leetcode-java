

## 动态规划
> 查表的递归。如果说递归是从问题的结果倒推，直到问题的规模缩小到寻常。那么动态规划就是从寻常入手，逐步扩大规模到最优子结构。
### 1. 1130_Minimum Cost Tree From Leaf Values
> 题目
> >Given an array arr of positive integers, consider all binary trees such that:
> >+ Each node has either 0 or 2 children;
> >+ The values of arr correspond to the values of each leaf in an in-order traversal of the tree.  (Recall that a node is a leaf if and only if it has 0 children.)
> >+ The value of each non-leaf node is equal to the product of the largest leaf value in its left and right subtree respectively.
> >+ Among all possible binary trees considered, return the smallest possible sum of the values of each non-leaf node.  It is guaranteed this sum fits into a 32-bit integer.
### 思路一：动态规划

状态转移方程: ![1130状态转移方程.jpg](/Users/shuiyingying/leetcode/leetcode-java/img/1130状态转移方程.jpg)

代码实现：

 ```
dp[start][start+1]=0;
dp=min(dp,findMinSum(arr,start,i)+findMinSum(arr,i,end)+findMaxNum(arr,start,i)*findMaxNum(arr,i,end));
 ```

*需要一个记录数组避免重复计算，否则会超时*



### 思路二：单调栈

-----------------------------------------------------------------------

## 53_Maximum Subarray

> 题目
>
> > Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

### 思路一：动态规划

当前位置i的最大子序列和为`dp[i]`，则有状态转移方程：
```
dp[i]=max(dp[i-1]+nums[i],nums[i]);
dp[0]=nums[0];
```

### 思路二：前缀和法

